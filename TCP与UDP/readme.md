# 传输层的作用  

TCP/IP中有两个具有代表性的传输层协议， 它们分别是TCP和UDP。 TCP提供可靠的通信传输， 而UDP则常被用于让广播和细节控制交给应用的通信传输。   

## 传输层定义  

传输层的TCP和UDP， 为了识别自己所传输的数据部分究竟应该发给哪个应用， 也设定了这样一个编号。  根据端口号就可以识别在传输层上一层的应用层中所要进行处理的具体程序（一个程序可以使用多个端口。 ） 。  

## 通信处理  

![](./img/http_query.png)

传输协议TCP、 UDP通过接收数据中的目标端口号识别目标处理程序。   

## 两种传输层协议TCP和UDP  

### TCP  

TCP是面向连接的、 可靠的流协议。 流就是指不间断的数据结构，当应用程序采用TCP发送消息时， 虽然可以保证发送的顺序， 但还是犹如没有任何间隔的数据流发送给接收端。

TCP为提供可靠性传输， 实行“顺序控制”或“重发控制”机制。 此外还具备“流控制（流量控制） ”、 “拥塞控制”、 提高网络利用率等众多功能。       

### UDP  

UDP是不具有可靠性的数据报协议。 细微的处理它会交给上层的应用去完成。 在UDP的情况下， 虽然可以确保发送消息的大小， 却不能保证消息一定会到达。 因此， 应用有时会根据自己的需要进行重发处理。    

##　TCP与UDP区分  

TCP用于在传输层有必要实现可靠传输的情况。 由于它是面向有连接并具备顺序控制、 重发控制等机制的， 所以它可以为应用提供可靠传输。  

UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。   

因此， TCP和UDP应该根据应用的目的按需使用。  

# 端口号  

## 端口号定义  

数据链路和IP中的地址， 分别指的是MAC地址和IP地址。 前者用来识别同一链路中不同的计算机， 后者用来识别TCP/IP网络中互连的主机和路由器。 在传输层中也有这种类似于地址的概念， 那就是端口号。 端口号用来识别同一台计算机中进行通信的不同应用程序。 因此， 它也被称为程序地址。  

## 根据端口号识别应用  

![](./img/Port_app.png)

传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序， 并准确地将数据传输。  

## 通过IP地址、 端口号、 协议号进行通信识别  

![](./img/multi_query.png)

仅凭目标端口识别某一个通信是远远不够的。  

①和②的通信是在两台计算机上进行的。 它们的目标端口号相同， 都是80。   在这种情况下也必须严格区分这两个通信。 因此可以根据源端口号加以区分。  

③跟①的目标端口号和源端口号完全相同， 但是它们各自的源IP地址不同。   

此外， 还有一种情况上图中并未列出， 那就是IP地址和端口全都一样， 只是协议号（表示上层是TCP或UDP的一种编号） 不同。这种情况下， 也会认为是两个不同的通信。  

因此， TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。 它们是“源IP地址”、 “目标IP地址”、 “协议号”、 “源端口号”、 “目标端口号”。 只要其中某一项不同， 则被认为是其他通信。    

## 端口号如何确定  

在实际进行通信时， 要事先确定端口号。 确定端口号的方法分为两种：  

### 标准既定的端口号  

这种方法也叫静态方法。 它是指每个应用程序都有其指定的端口号。 但并不是说可以随意使用任何一个端口号。 每个端口号都有其对应的使用目的。

例如， HTTP、 TELNET、 FTP等广为使用的应用协议中所使用的端口号就是固定的。 这些端口号也被称之为知名端口号（Well-Known Port Number） 。   

除知名端口号之外， 还有一些端口号也被正式注册。 它们分布在1024到49151的数字之间。 不过， 这些端口号可用于任何通信用途。   

### 时序分配法  

第二种方法也叫时序（或动态的） 分配法。 此时， 服务端有必要确定监听端口号， 但是接受服务的客户端没必要确定端口号。  

动态分配的端口号取值范围在49152到65535之间。  

## 端口号与协议  

端口号由其使用的传输层协议决定。 因此， 不同的传输协议可以使用相同的端口号。 例如， TCP与UDP使用同一个端口号， 但使用目的各不相同。 这是因为端口号上的处理是根据每个传输协议的不同而进行的。  

数据到达IP层后， 会先检查IP首部中的协议号， 再传给相应协议的模块。 如果是TCP则传给TCP模块、如果是UDP则传给UDP模块去做端口号的处理。 即使是同一个端口号， 由于传输协议是各自独立地进行处理， 因此相互之间不会受到影响。  

此外， 那些知名端口号与传输层协议并无关系， 只要端口一致都将分配同一种程序进行处理。例如， 53号端口在TCP与UDP中都用于DNS服务， 而80端口用于HTTP通信。 从目前来看， 由于HTTP通信必须使用TCP， 因此UDP的80端口并未投入使用。 但是将来， 如果HTTP协议的实现也开始应对UDP协议以及应用协议被相应扩展的情况下， 就可以原样使用与TCP保持相同的80端口号了。     

TCP具有代表性的知名端口号：

![](./img/tcp_port.png)

UDP具有代表性的知名端口号：

![](./img/udp_port.png)

# UDP

UDP是User Datagram Protocol的缩写。

UDP不提供复杂的控制机制， 利用IP提供面向无连接的通信服务。 并且它是将应用程序发来的数据在收到的那一刻， 立即按照原样发送到网络上的一种机制。  

即使是出现网络拥堵的情况下， UDP也无法进行流量控制等避免网络拥塞的行为。 此外， 传输途中即使出现丢包， UDP也不负责重发。 甚至当出现包的到达顺序乱掉时也没有纠正的功能。 如果需要这些细节控制， 那么不得不交由采用UDP的应用程序去处理。

由于UDP面向无连接， 它可以随时发送数据。 再加上UDP本身的处理既简单又高效， 因此经常用于以下几个方面：  

- 包总量较少的通信（DNS、 SNMP等）
- 视频、 音频等多媒体通信（即时通信）
- 限定于LAN等特定网络中的应用通信
- 广播通信（广播、 多播）  

# TCP  

UDP是一种没有复杂控制， 提供面向无连接通信服务的一种协议。 换句话说， 它将部分控制转移给应用程序去处理， 自己却只提供作为传输层协议的最基本功能。  

TCP与UDP的区别相当大。 它充分地实现了数据传输时各种控制功能， 可以进行丢包时的重发控制， 还可以对次序乱掉的分包进行顺序控制。 而这些在UDP中都没有。 此外， TCP作为一种面向有连接的协议， 只有在确认通信对端存在时才会发送数据， 从而可以控制通信流量的浪费。

##　TCP的特点及其目的  

为了通过IP数据报实现可靠性传输， 需要考虑很多事情， 例如数据的破坏、 丢包、 重复以及分片顺序混乱等问题。

TCP通过检验和、 序列号、 确认应答、 重发控制、 连接管理以及窗口控制等机制实现可靠性传输。  

## 通过序列号与确认应答提高可靠性  

在TCP中， 当发送端的数据到达接收主机时， 接收端主机会返回一个已收到消息的通知。 这个消息叫做确认应答（ACK（ACK（Positive Acknowled-gement） 意指已经接收。 ） ） 。  

![](./img/ack.png)

TCP通过肯定的确认应答（ACK） 实现可靠的数据传输。 当发送端将数据发出之后会等待对端的确认应答。 如果有确认应答， 说明数据已经成功到达对端。 反之， 则数据丢失的可能性很大。  

在一定时间内没有等到确认应答， 发送端就可以认为数据已经丢失， 并进行重发。 由此， 即使产生了丢包， 仍然能够保证数据能够到达对端， 实现可靠传输。  

![](./img/miss_resend.png)

未收到确认应答并不意味着数据一定丢失。 也有可能是数据对方已经收到， 只是返回的确认应答在途中丢失。 这种情况也会导致发送端因没有收到确认应答， 而认为数据没有到达目的地， 从而进行重新发送。   

![](./img/miss_ack.png)

序列号是按顺序给发送数据的每一个字节（8位字节） 都标上号码的编号（序列号的初始值并非为0。 而是在建立连接以后由随机数生成。 而后面的计算则是对每一字节加一。 ） 。 接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。 就这样， 通过序列号和确认应答号， TCP可以实现可靠传输。  

![](./img/send_data.png)

- 序列号（或确认应答号） 也指字节与字节之间的分隔  
- TCP的数据长度并未写入TCP首部。 实际通信中求得TCP包的长度的计算公式是： IP首部中的数据包长度-IP首部长度TCP首部长度。  

## 重发超时如何确定  

重发超时是指在重发数据之前， 等待确认应答到来的那个特定时间间隔。 如果超过了这个时间仍未收到确认应答， 发送端将进行数据重发。   

TCP要求不论处在何种网络环境下都要提供高性能通信， 并且无论网络拥堵情况发生何种变化， 都必须保持这一特性。 为此， 它在每次发包时都会计算往返时间（Round Trip Time也叫RTT。 是指报文段的往返时间。 ） 及其偏差（RTT时间波动的值、 方差。 有时也叫抖动。 ） 。 将这个往返时间和偏差相加重发超时的时间， 就是比这个总和要稍大一点的值。  

![](./img/rtt.png)

数据被重发之后若还是收不到确认应答， 则进行再次发送。 此时， 等待确认应答的时间将会以2倍、 4倍的指数函数延长。

此外， 数据也不会被无限、 反复地重发。 达到一定重发次数之后， 如果仍没有任何确认应答返回， 就会判断为网络或对端主机发生了异常， 强制关闭连接。 并且通知应用通信异常强行终止。  















